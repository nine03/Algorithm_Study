재귀(recursive) <br>
어떤 사건이 자기 자신을 포함하고다시 자기 자신을 사용하여 정의될때 재귀적이라고 한다. 이러한 재귀의 개념을 사용하면 1부터 시작하여 2, 3, ... 과 같이 무한하게 이어지는 자연수를 아래처럼 정의할 수 있다.

```
1. 1은 자연수이다.
2. 자연수 n의 바로 다음 수도 자연수이다.
```

재귀적 정의(recursive definition)에 의해 무한으로 존재하는 자연수를 위의 두문장으로 정의 할 수 있다. 재귀를 효과적으로 사용하면 이런 정의뿐만 아니라 프로그램도 간결하게 할 수 있다. <br>

팩토리얼 구하기 <br>
음이 아닌 정수 n의 팩토리얼(n!)은 아래처럼 재귀적으로 정의할 수 있다. <br>

```
1. 0! = 1
2. n > 0이면 n! = n * (n - 1)!
```

factorial 메서드는 매개변수 n에 전달받은 값이 0보다 크면n * factorial(n - 1)을 반환하고, 그렇지 않으면 1을 반환한다. <br>

재귀 호출 <br>
factorial 메서드를 사용해 3의 팩토리얼 값을 구체적으로 구하는 과정이다. <br>

메서드 호출식 factorial(3)을 실행하면 factorial 메서드가 시작된다. 이 메서드는 매개변수 n에 3을 전달받아 3 * factorial(2)를 반환한다. 그런데 이 곱셈을 수행하려면 factorial(2)의 값을 구해야 한다. 2를 다시 매개 변수로 전달하고 factorial 메서드를 호출한다. <br>

호출된 factorial 메서드는 매개변수 n에 2를 전달받는다. 다시 곱셈 * factorial(1)을 수행하기 위해 factorial 메서드를 호출한다. <br>

다시 호출된 factorial 메서드는 매개변수 n에 1을 전달받는다. 1 * factorial(0)을 수행하기 위해 factorial 메서드를 호출한다. <br>

호출된 factorial 메서드는 매개변수 n에 전달받은 값이 0이므로 1을 반환한다. <br>

위와 같은 방법으로 factorial(3)을 사용해 팩토리얼 값 6을 얻을 수 있다. factorial 메서드는 n - 1의 팩토리얼 값을 구하기 위해 다시 factorial 메서드를 호출한다. 이러한 메서드 호출방식을 재귀호출(recursive call)이라고 한다. <br>

재귀 호출은 '메서드 자신'을 호출하는 것이라고 이해하기보다는 '자기 자신과 똑같은 메서드'를 호출한다고 이해하는것이 자연스럽다. 만약 진짜로 메서드 자신을 호출하면 끝없이 자기 자신을 호출하는 행위를 계속하는 행위이다. <br>

직접 재귀와 간접 재귀 <br>
factorial 메서드는 그 내부에서 factorial 메서드를 호출한다. 이처럼 자신과 같은 메서드를 호출하면 직접(direct)재귀이다. 간접(indirect)재귀는 메서드 a가 메서드 b를 호출하고, 다시 메서드 b가 메서드 a를 호출하는 구조로 이루어진다. <br>

유클리드 호제법 <br>
두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법. 두 정수를 직사각형의 두 변의 길이라고 생각하면 두 정수의 최대공약수를 구하기는 문제는 다음 문제 처럼 바꿀수 있다.

```
직사각형을 정사각형으로 완전히 채운다. 이렇게 만들 수 있는 정사각형의 가장 긴 변의 길이를 구해라.
```

22 * 8 크기의 직사각형에서 짧은 변(8)을 한 변으로 하는 정사각형으로 분할한다. 이렇게 하면 8 * 8 크기의 정사각형 타일 2장이 생긴다. 그리고 8 * 6 크기의 직사각형이 1개 남는다. <br>

남은 8 * 6 크기의 직사각형으로 다시 같은 과정을 수행한다. 6 * 6 크기의 정사각형이 1개, 6 * 2 크기의 직사각형이 1개 남는다. <br>

다시 남은 6 * 2 크기의 직사각형으로 같은 과정을 수행한다. 이번에는 2 * 2 크기의 정사각형 3개로 나눌 수 있다. 여기서 얻은 2가 최대공약수이다. <br>

이렇게 두 정수가 주어질 경우 큰 값을 작은 값으로 나누었을때 나누어떨어지는 가장 작은 값이 최대공약수이다. 나누어지지 않으면 작은 값에 대해 나누어떨어질때까지 같은 과정을 재귀적으로 반복한다. <br>

이 과정을 좀 더 수학적으로 표현하기 위해 두 정수 x, y의 최대공약수를 gcd(x,y)로 표기한다. x = az와 y = bz를 만족하는 정수 a, b와 최대의 정수 z가 존재할 때 z를 gcd(x,y)라고 할 수 있다. 다시 말해 최대공약수는 y가 0이면 x이고, y가 0이 아니면 gcd(y, x % y)로 구한다. 이 알고리즘을 유클리드 호제법(Euclidean method of mutual division)이라고 한다. 

재귀 알고리즘 분석 <br>
재귀 알고리즘을 분석하기 위한 하향식(top down) 분석과 상향식(bottom up) 분석을 살펴보고 재귀 알고리즘을 비재귀적으로 구현하는 방법을 공부한다. <br>

recur 메서드는 factorial 메서드나 gcd 메서드와 달리 메서드 안에서 재귀 호출을 2회 실행한다. 이처럼 재귀 호출을 여러 회 실행하는 메서드를 순수하게(genuinely) 재귀적이라 하며, 실제 동작은 매우 복잡하다. <br>

하향식 분석(top down) <br>
매개변수 n으로 4를 전달하면 recur메서드는 아래 과정을 순서대로 실행한다. <br>

```
1. recur(3)을 실행한다.
2. 4를 출력한다.
3. recur(2)를 실행한다.
```

4를 출력하는 것은 recur(3) 실행이 완료된 다음이다. 따라서 recur(3)을 먼저 조사해야 한다. 가장 위쪽에 위치한 상자의 메서드 호출부터 시작해 계단식으로 자세히 조사하는 분석 기법을 하향식 분석(top-down analysis)이라고 한다. 그런데 recur(1), recur(2)의 호출이 여러 번 있다(같은 호출이 여러 번 있다). 꼭대기(top)부터 분석하면 이렇게 같은 메서드의 호출이 여러 번 나올 수 있기 때문에 '하향식 분석이 반드시 효율적이다'라고 말할 수는 없다. <br>

상향식 분석(bottom up) <br>
위쪽부터 분석하는 하향식 분석과는 대조적으로 아래쪽부터 쌓아 올리며 분석하는 방법이 상향식 분석(bottom-up analysis)이다. recur 메서드는 n이 양수일 때만 실행하므로 먼저 recur(1)을 생각해 봐야한다. recur(1)이 수행하는 작업은 아래와 같다. <br>

```
1. recur(0)을 실행한다.
2. 1을 출력한다.
3. recur(-1)을 실행한다.
```

recur(0)과 recur(-1)은 출력할 내용이 없다. 따라서 1만 출력한다. 그럼 recur(2)에 대해 생각해봐야한다. <br>

```
1. recur(1)을 실행한다.
2. 2를 출력한다.
3. recur(0)을 실행한다.
```

recur(1)은 1을 출력하고 recur(0)은 출력할 내용이 없다. 전체과정을 거치면 1과 2가 출력된다. <br>

재귀 알고리즘의 비재귀적 표현 <br>

꼬리 재귀의 제거 <br>
메서드의 꼬리에서 재귀 호출하는 메서드 recur(n - 2)라는 말은 '인자로 n - 2를 전달하여 recur메서드를 호출한다' 는 의미이다. 따라서 이 호출은 아래처럼 바꿀 수 있다. <br>

```
n의 값을 n - 2로 업데이트하고 메서드의 시작 지점으로 돌아간다.
```

메서드의 끝에서 실행하는 꼬리 재귀(tail recursion)는 쉽게 제거할 수 있다. <br>

재귀의 제거 <br>
꼬리 재귀와는 다르게 앞에서 호출한 재귀 메서드의 제거는 쉽지 않다. 왜냐하면 변수 n의 값을 출력하기 전에 recur(n - 1)을 먼저 수행해야 하기 때문이다. n이 4인 경우 재귀 호출 recur(3)의 처리가 완료되지 않으면 n의 값인 '4'를 저장해야 한다. 그래서 재귀 호출 recur(n - 1)을 아래 처럼 바로 바꿀 수 없다. <br>

```
n의 값을 n - 1로 업데이트하고 메서드의 시작 지점으로 돌아간다. 
```

왜냐하면 다음과 같은 처리를 미리 해야 하기 때문이다. <br>

```
현재 n의 값을 '잠시' 저장한다.
```

또 recur(n - 1)의 처리가 완료된 다음에 n의 값을 출력할 때는 다음 과정을 따르게 된다. <br>

```
저장했던 n을 다시 꺼내 그 값을 출력한다.
```

이런 재귀 호출을 제거하기 위해서는 변수 n의 값을 '잠시' 저장해야 한다는 사실을 알았다. 이때 이런 문제를 잘 해결할 수 있는 데이터 구조가 바로 스택(stack)이다. <br>

스택을 사용하여 비재귀적으로 구현한 recur 메서드이다. <br>

매개변수로 전달받은 값 '4'는 0보다 크므로 맨 앞의 if문에 의해 다음과 같은 과정이 진행된다. <br>

```
1. n값 4를 스택에 푸시한다.
2. n값을 하나 줄여 3으로 만든다.
3. continue문에 의해 while문의 처음으로 돌아간다.
4. 스택에서 팝한 값 1을 n에 꺼내 놓는다.
5. n값 1을 출력한다.
6. n값을 2 줄여 -1로 만든다.
7. continue문에 의해 while문의 처음으로 돌아간다.
```



- 这个项目是我为了重新学习Algorithm而做的项目（이 프로젝트는 내가 Algorithm를 다시 공부하기위해서 만든 프로젝트입니다.）
