검색(searching) <br>
어떤 검색을 하게 되더라도 데이터를 찾는 방법이다.

키(key) <br>
데이터가 단순한 정숫값이면 데이터 값을 키 값이락 생각해도 좋지만 대부분의 경우에서 키는 데이터의 '일부'이다.

배열에서 검색하기 <br>
1. 선형 검색 : 무작위로 늘어놓은 데이터 모임에서 검색을 수행한다.
2. 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행한다.
3. 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행한다.
- 체인법 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법이다.
- 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법이다.

선형 검색(linear search) <br>
요소가 직전 모양으로 늘어선 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하면 되는데, 이것이 선형 검색(linear search) 또는 순차 검색(sequential search)이라는 알고리즘이다.

무한 루프 <br>

```
while(true) {
  // ... 중략 ...
}
```

```
for(;;) {
  // ... 중략 ...
}
```

```
do {
  // ... 중략 ...
} while(true);
```

보초법(sentinel method) <br>
반복의 종료를 알리는 특정한 값인 보초(Sentinel) 값을 사용하여 종료 조건중 검색 실패 조건을 제거하여 판단 횟수를 줄이는 방법이다.

이진 검색(binary search)
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다. <br>
이진 탐색은 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 검색 범위가 절반으로 줄기 때문에 속도가 빠르다는 장점이 있습니다.

```
ex) 
검색 범위의 맨 앞 인덱스를 pl, 맨 끝 인덱스를 pr, 중앙 인덱스를 pc라고 지정한다. 
검색을 시작할때 pl은 0, pr은 n - 1, pr는 (n - 1) / 2로 초기화한다. 
```

![11221](https://user-images.githubusercontent.com/60682087/173272027-cb241d7a-2970-423a-b372-a77d1173ee42.JPG)

a[pc] < key일때 <br>
a[pl] ~ a[pc]는 key보다 작은 것이 분명하므로 검색 대상에서 제외한다. 검색 범위는 중앙요소 a[pc]보다 뛰쪽의 a[pc + 1] ~ a[pr]로 좁힌다. 그런 다음 pl의 값을 pc + 1로 업데이트한다.

a[pc] > key일때 <br>
a[pc] ~ a[pr]은 key보다 큰 것이 분명하므로 검색 대상에서 제외한다. 검색 범위는 중앙요소 a[pc]보다 앞쪽 a[pl] ~ a[pc - 1]로 좁힌다. 그런 다음 pr의 값을 pc - 1로 업데이트한다.

이진 검색은 반복할 때마다 검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균값은 log n이다. 검색에 실패한 경우는 [log(n + 1)]회, 검색에 성공한 경우는 대략 log n - 1회이다. 

복잡도(complexity) <br>
프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라 진다. 알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도라고 한다.

1. 시간 복잡도(time complexity) : 실행에 필요한 시간을 평가한것 
2. 공간 복잡도(space complexity) : 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것 

선형 검색의 시간 복잡도 
```
static int seqSearch(int[] a, int n, int key) {
  int i = 0;  // 1
  while(i < n) { // 2
    if(a[i] == key) // 3
      return i; //  검색 성공 4
      i++; // 5
  }
  return -1; // 검색 실패 6
}
```

변수 i에 0을 대입하는 횟수는 처음 한번 실행한 이후에는 없다(데이터 수 n과는 무관하다). 이렇게 한 번만 실행하는 경우 복잡도는 O(1)로 표기한다. 메서드에서 값을 반환하는 4와 6도 한 번만 실행하기 때문에 O(1)로 표기한다. 배열의 맨 끝에 도달했는지를 판단하는 2와 현재 검사하고 있는 요소와 찾고자 하는 값이 같은지를 판단하는 3의 평균 실행 횟수는 n/2이다. n에 비례하는 횟수만큼 실행하는 경우의 복잡도를 O(n)으로 표기한다. 

복잡도를 표기할 때 사용하는 O는 Order에서 따온 것으로, O(n)은 'O - n', 'Order n', 'n의 Order'라고 읽는다.

컴퓨터에게 n/2과 n의 차이는 크지 않다. <br>
n/2번 실행했을 때 복잡도를 O(n/2)가 아닌 O(n)으로 표현하는 이유는 n의 값이 무한히 커진다고 가정했을 때, 그 값의 차이가 무의미해지기 때문이다. 마찬가지로 100번만 실행하는 경우에도 O(100)이 아닌 O(1)로 표시한다. 컴퓨터가 100번을 계싼하는 시간과 1번만 계산하는 시간의 차이는 사람이 느낄 수 없을 정도로 굉장히 작다.

|단계|실행 횟수|복잡도|
|------|---|---|
|1|1|O(1)|
|2|n/2|O(n)|
|3|n/2|O(n)|
|4|1|O(1)|
|5|n/2|O(n)|
|6|1|O(1)|

n이 점점 커지면 O(n)에 필요한 계싼 시간은 n에 비례하여 점점 길어진다. 이와달리 O(1)에 필요한 계산 시간은 변하지 않는다. 일반적으로 O(f(n))과 O(g(n))의 복잡도를 계싼하는 방법은 아래와 같다.

```
O(f(n)) + O(g(n)) = O(max(f(n), g(n))) // max(a,b)는 a와 b 가운데 큰 쪽을 나타내는 메서드이다.
```

2개 이상의 복잡도로 구성된 알고리즘은 전체 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시한다. 둘아 아니라 셋 이상의 계산으로 구성된 알고리즘도 마찬가지이다. 전체 복잡도는 차원이 가장 높은 복잡도를 선택한다. 그러므로 선형 검색 알고리즘의 복잡도를 구하면 아래처럼 O(n)이 된다. 

```
O(1) + O(n) + O(n) + O(1) + O(n) + O(1)  = O(max(1, n, n, 1, n, 1)) = O(n) 
```

이진 검색의 시간 복잡도 
```
static int binSearch(int[] a,int n, int key) {
  int pl = 0; // 검색 범위 맨 앞의 인덱스 1
  int pr = n - 1; // 검색 범위 맨 끝의 인덱스 2
  
  do {
    int pc = (pl + pr) / 2; // 중앙 요소의 인덱스 3
    if(a[pc] == key) // 4
      return pc; // 검색 성공 5
    else if(a[pc] < key) // 6
      pl = pc + 1; // 검색 범위를 뒤쪽 반으로 좁힘 7
    else 
      pr = pc - 1; // 검색 범위를 앞쪽 반으로 좁힘 8
  } while(pl <= pr); // 9
    return -1; // 검색 실패 10
}
```

|단계|실행 횟수|복잡도|
|------|---|---|
|1|1|O(1)|
|2|1|O(1)|
|3|log n|O(log n)|
|4|log n|O(log n)|
|5|1|O(1)|
|6|log n|O(log n)|
|7|log n|O(log n)|
|8|log n|O(log n)|
|9|log n|O(log n)|
|10|1|O(1)|

이진 검색 알고리즘 복잡도를 구하면 아래처럼 O(log n)을 얻을 수 있다. <br>1
 ```
 O(1) + O(1) + O(log n) + O(log n) + O(1) + O(log n) + ... + O(1) = O(log n)
 ```
 
 O(n)과 O(log n)은 O(1)보다 크다. <br>
 복잡도의 대소 관계를 그림으로 나타내면 다음과같다. <br>
 ![11122](https://user-images.githubusercontent.com/60682087/173320403-686d7236-7d57-45e6-a9d4-e7c737964bd6.JPG)
 
 Arrays.binarySearch에 의한 이진 검색 <br>
 Java는 배열에서 이진 검색을 하는 메서드를 표준 라이브러리로 제공한다. 이진 검색 표준 라이브러리의 메서드로는 java.util.Arrays 클래스의 binartSearch 메서드가 있다. 
 
 장점 <br>
 1. 이진 검색 메서드를 직접 코딩할 필요가 없다.
 2. 모든 자료형 배열에서 검색할 수 있다.
 
 binarySearch 메서드는 오름차순으로 정렬된 배열 a를 가정하고, 키 값이 key인 요소를 이진 검색한다. binarySearch 메서드는 자료형에 따라 9 가지 방법으로 오버로딩(overloading)되어 있다.
 
 ```
 1. static int binarySearch(byte[] a, byte key)
 2. static int binarySearch(char[] a, char key)
 3. static int binarySearch(double[] a, double key)
 4. static int binarySearch(float[] a, float key)
 5. static int binarySearch(int[] a, int key)
 6. static int binarySearch(long[] a, long key)
 7. static int binarySearch(short[] a, short key)
 8. static int binarySearch(Object[] a, Object key)
 9. static <T> int binarySearch(T[] a, T key, Comparator <? super T > c)
 ```
 
 검색에 성공한 경우 <br>
 key와 일치하는 요소의 인덱스를 반환한다. 일치하는 요소가 여러 개 있다면 무작위의 인덱스를 반환한다. 맨 앞의 인덱스나 어떤 특정한 인덱스를 반환하는 것이 아니다.
 
 검색에 실패한 경우 <br>
 반환값은 삽입 포인트를 x라고 할때 -x -1을 반환한다. 삽입 포인트는 검색하기 위해 지정한 key보다 큰 요소 중 첫 번째 요소의 인덱스이다. 만약 배열의 모든 요소가 key보다 작다면 배열의 길이를 삽입 포인트로 정한다.
 
 ![231](https://user-images.githubusercontent.com/60682087/173361129-0f6809c5-57c7-4e1f-99ef-608abb47f4db.JPG)

위의 배열에서 key가 4이면 삽입 포인트는 3이다. 즉 -4를 반환한다. 






- 这个项目是我为了重新学习Algorithm而做的项目（이 프로젝트는 내가 Algorithm를 다시 공부하기위해서 만든 프로젝트입니다.）
