검색(searching) <br>
어떤 검색을 하게 되더라도 데이터를 찾는 방법이다.

키(key) <br>
데이터가 단순한 정숫값이면 데이터 값을 키 값이락 생각해도 좋지만 대부분의 경우에서 키는 데이터의 '일부'이다.

배열에서 검색하기 <br>
1. 선형 검색 : 무작위로 늘어놓은 데이터 모임에서 검색을 수행한다.
2. 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행한다.
3. 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행한다.
- 체인법 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법이다.
- 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법이다.

선형 검색(linear search) <br>
요소가 직전 모양으로 늘어선 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하면 되는데, 이것이 선형 검색(linear search) 또는 순차 검색(sequential search)이라는 알고리즘이다.

무한 루프 <br>

```
while(true) {
  // ... 중략 ...
}
```

```
for(;;) {
  // ... 중략 ...
}
```

```
do {
  // ... 중략 ...
} while(true);
```

보초법(sentinel method) <br>
반복의 종료를 알리는 특정한 값인 보초(Sentinel) 값을 사용하여 종료 조건중 검색 실패 조건을 제거하여 판단 횟수를 줄이는 방법이다.

이진 검색(binary search)
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다. <br>
이진 탐색은 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 검색 범위가 절반으로 줄기 때문에 속도가 빠르다는 장점이 있습니다.

```
ex) 
검색 범위의 맨 앞 인덱스를 pl, 맨 끝 인덱스를 pr, 중앙 인덱스를 pc라고 지정한다. 
검색을 시작할때 pl은 0, pr은 n - 1, pr는 (n - 1) / 2로 초기화한다. 
```

![11221](https://user-images.githubusercontent.com/60682087/173272027-cb241d7a-2970-423a-b372-a77d1173ee42.JPG)

a[pc] < key일때 <br>
a[pl] ~ a[pc]는 key보다 작은 것이 분명하므로 검색 대상에서 제외한다. 검색 범위는 중앙요소 a[pc]보다 뛰쪽의 a[pc + 1] ~ a[pr]로 좁힌다. 그런 다음 pl의 값을 pc + 1로 업데이트한다.

a[pc] > key일때 <br>
a[pc] ~ a[pr]은 key보다 큰 것이 분명하므로 검색 대상에서 제외한다. 검색 범위는 중앙요소 a[pc]보다 앞쪽 a[pl] ~ a[pc - 1]로 좁힌다. 그런 다음 pr의 값을 pc - 1로 업데이트한다.

이진 검색은 반복할 때마다 검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균값은 log n이다. 검색에 실패한 경우는 [log(n + 1)]회, 검색에 성공한 경우는 대략 log n - 1회이다. 

복잡도(complexity) <br>
프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라 진다. 알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도라고 한다.

1. 시간 복잡도(time complexity) : 실행에 필요한 시간을 평가한것 
2. 공간 복잡도(space complexity) : 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것 

선형 검색의 시간 복잡도 
```
static int seqSearch(int[] a, int n, int key) {
  int i = 0;  // 1
  while(i < n) { // 2
    if(a[i] == key) // 3
      return i; //  검색 성공 4
      i++; // 5
  }
  return -1; // 검색 실패 6
}
```

변수 i에 0을 대입하는 횟수는 처음 한번 실행한 이후에는 없다(데이터 수 n과는 무관하다). 이렇게 한 번만 실행하는 경우 복잡도는 O(1)로 표기한다. 메서드에서 값을 반환하는 4와 6도 한 번만 실행하기 때문에 O(1)로 표기한다. 배열의 맨 끝에 도달했는지를 판단하는 2와 현재 검사하고 있는 요소와 찾고자 하는 값이 같은지를 판단하는 3의 평균 실행 횟수는 n/2이다. n에 비례하는 횟수만큼 실행하는 경우의 복잡도를 O(n)으로 표기한다. 

복잡도를 표기할 때 사용하는 O는 Order에서 따온 것으로, O(n)은 'O - n', 'Order n', 'n의 Order'라고 읽는다.


- 这个项目是我为了重新学习Algorithm而做的项目（이 프로젝트는 내가 Algorithm를 다시 공부하기위해서 만든 프로젝트입니다.）
