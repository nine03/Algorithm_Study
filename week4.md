스택(stack) <br>
스택은 데이터를 일시적으로 저장하기 위해 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO, Last In First Out)이다. (가장 나중에 넣은 데이터를 가장 먼저 꺼낸다). <br>
스택에 데이터를 넣는 작업을 푸시(push)라 하고, 스택에서 데이터를 꺼내는 작업을 팝(pop)이라고 한다. 테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행한다. 이렇게 푸시와 팝을 하는 위치를 꼭대기(top)라 하고, 스택의 가장 아랫부분을 바닥(bottom)이라고 한다.

스택 만들기 <br>
스택 본체용 배열 : stk <br>
푸시된 데이터를 저장하는 스택 본체의 배열이다. 인덱스 0인 요소가 스택의 바닥(bottom)이다. 가장 먼저 푸시된 데이터를 저장하는 곳은 stk[0]이다.

```
class IntStack {
    int max; // 스택 용량
    int ptr; // 스택 포인터
    int[] stk; // 스택의 본체
}
```

스택 용량 : max <br>
스택의 용량(스택에 쌓을 수 있는 최대 데이터 수)을 나타내는 필드이다. 이값은 배열 stk의 욧솟수와 같다.

스택 포인터 : ptr <br>
스택에 쌓여 있는 데이터 수를 나타내는 필드이다. 이 값은 스택 포인터(stack pointer)라고 한다.

생성자 IntStack <br>
생성자는 스택 본체용 배열을 생성하는 등 준비 작업을 수행한다. 생성 시 스택은 비어 있으므로(데이터가 하나도 쌓여 있지 않은 상태) 스택 포인터 ptr 값을 0으로 한다. 그리고 매개변수 capacity로 전달받은 값을 스택 용량을 나타내는 max에 복사하고 요솟수가 max인 배열 stk의 본체를 생성한다. 따라서 스택 본체의 개별 요소는 바닥부터 stk[0], stk[1], ... stk[max - 1]이 된다.

푸시 메서드 push <br>
스택에 데이터를 푸시하는 메서드이다. 스택이 가득 차서 푸시할 수 없는 경우 예외 OverflowIntStackException을 던진다(throw). <br>
예외 처리를 빼면 실질적으로는 1행만으로 된 메서드이다. 전달받은 데이터 x를 배열 요소 stk[ptr]에 저장하고, 스택 포인터를 증가(increment)시킨다. 메서드의 반환값은 푸시한 값이다. 클래스 IntStack의 생성자와 메서드를 사용하여 스택 작업을 수행하면 스택 포인터 ptr 값은 반드시 0 이상 max이하가 된다. 따라서 스택이 가득 찼는지에 대한 검사는 관계 연산자(>=)가 아니라 등가 연산자(==)를 사용하여 다음과 같이 수행할 수 있다.

```
if(ptr == max)
```

그러나 프로그래밍 실수와 같은 원인으로 인하여 ptr 값이 잘못 입력되면 max를 초과할 수도 있다. 하지만 위와 같이 부등호로 판단하면 스택 본체 배열의 상한과 하한을 벗어나서 접근하는 것을 막을 수 있다. 간단한 코드 수정이지만 이런 노력으로 프로그램의 안정성을 높일 수 있다.

팝 메서드 pop <br>
스택의 꼭대기에서 데이터를 팝(제거)하고 그 값을 반환하는 메서드이다. 스택이 비어 있어 팝을 할 수 없는 경우 예외 EmptyIntStackException을 던진다(throw). 스택 포인터 ptr의 값을 감소시키고(decrement) 그때 stk[ptr]에 저장되어 있는 값을 반환한다.

피크 메서드 peek <br>
스택의 꼭대기에 있는 데이터를 몰래 엿보는 메서드이다. 스택이 비어 있는 경우 예외 EmptyIntStackException을 던진다(throw). 스택이 비어 있지 않으면 꼭대기의 요소 stk[ptr - 1]의 값을 반환한다. 이때 데이터의 입력과 출입이 없으므로 스택 포인터는 변환하지 않는다.

검색 메서드 indexOf <br>
스택 본체의 배열 stk에 x와 같은 값의 데이터가 포함되어 있는지, 포함되어 있다면 배열의 어디에 들어 있는지를 조사하는 메서드이다. 검색은 꼭대기 쪽에서 바닥 쪽으로 선형 검색을 수행한다. 배열 인덱스가 큰쪽에서 작은 쪽으로 스캔한다. 검색에 성공하면 찾아낸 요소의 인덱스를 반환하고, 실패하면 -1을 반환한다.

스택의 모든 요소를 삭제하는 메서드 clear <br>
clear 메서드는 스택에 쌓여 있는 모든 데이터를 삭제하는 메서드이다. 스택에 대한 푸시와 팝 등 모든 작업은 스택 포인터를 바탕으로 이루어진다. 따라서 스택의 배열 요솟값을 변경할 필요가 없다. 모든 요소의 삭제는 스택 포인터 ptr값을 0으로 하면 끝난다. 

용량을 확인하는 메서드 capacity <br>
capacity 메서드는 스택의 용량(max의 값)을 반환하는 메서드이다. max값을 그래도 반환한다.

데이터 수를 확인하는 메서드 size <br>
size 메서드는 현재 스택에 쌓여 있는 데이터 수(ptr의 값)를 반환하는 메서드이다.

스택이 비어 있는지 검사하는 메서드 IsEmpty <br>
IsEmpty 메서드는 스택이 비어 있는지 검사하는 메서드이다. 스택이 비어 있으면 true, 그렇지 않으면 false를 반환한다. 

스택이 가득 찼는지 검사하는 메서드 IsFull <br>
IsFull 메서드는 스택이 가득 찼는지 검사하는 메서드이다. 스택이 가득 찼으면 true, 그렇지 않으면 false를 반환한다.

스택 안에 있는 모든 데이터를 표시하는 메서드 dump <br>
스택에 쌓여 있는 모든 데이터를 바닥에서 꼭대기 순으로 표시하는 메서드이다. 스택이 비어 있으면 '스택이 비어 있습니다.'라고 표시한다.

큐(Queue) <br>
큐는 스택과 마찬가지로 데이터를 일시적으로 쌓아 두기 위한 자료구조이다. 하지만 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출(FIFO, First In First Out)인 점이 스택과 다르다. <br>

큐에 데이터를 넣은 작업을 인큐(enqueue)라 하고, 데이터를 꺼내는 작업을 디큐(dequeue)라고 한다. 또 데이터를 꺼내는 쪽은 프런트(front)라 하고, 데이터를 넣는 쪽은 리어(rear)라고 한다. <br>

배열로 큐 만들기 <br>
배열의 프런트(front) 부터 4개(19, 22, 37, 53)의 데이터가 들어가 있는 모습이다. 배열 이름을 que라고 할 경우 que[0]부터 que[3]까지의 데이터가 저장된다. <br>
리어(rear)의 데이터가 저장된 que[3]의 다음 요소인 que[4]에 24를 저장한다. 이 처리의 복잡도는 O(1)이고 적은 비용으로 구현할 수 있다. <br>
que[0]에 저장된 19를 꺼낸 다음 두 번째 이후의 요소를 모두 맨 앞으로 옮긴다. 이 처리의 복잡도는 O(n)이며 데이터를 꺼낼 때마다 이런 처리를 하게 되면 효율이 떨어진다. 

링 버퍼로 큐 만들기 <br>
배열 요소를 앞쪽으로 옮기지 않는 큐를 구현하기. 이를 위해 사용하는 자료구조가 링 버퍼(ring buffer)이다. 링 버퍼는 배열의 처음이 끝과 연결되었다고 보는 자료구조이다. 여기서 논리적으로 어떤 요소가 첫 번째 요소이고 어던 요소가 마지막 요소인지 식별하기 위한 변수가 프런트(front)와 리어(rear)이다.

프런트(front) : 맨 처음 요소의 인덱스 <br>
리어(rear) : 맨 끝 요소의 하나 뒤의 인덱스(다음 요소를 인큐할 위치를 미리 지정) <br>

1. 7개의 데이터(35, 56, 24, 68, 95, 73, 19)가 차례대로 que[7] que[8], ... , que[11], que[0], que[1]에 저장된다. 프런트 값은 7이고 리어 값은 2이다. <br>

2. 82를 인큐한 다음의 상태이다, que[2]에 82를 저장한 다음 리어 값을 1만큼 증가한다. <br>

3. 35를 디큐한 다음의 상태이다. 프런트 요소(que[front], que[7])의 값 35를 빼고 프런트 값을 1만큼 증가한다. <br>

이렇게 큐를 구현하면 프런트와 리어 값을 업데이트하며 인큐와 디큐를 수행하기 때문에 앞에서 발생한 요소 이동 문제를 해결할 수 있다. 물론 처리의 복잡도는 O(1)이다. <br>

큐 클래스 IntQueue <br>
큐를 관리하는 클래스로, 아래와 같이 5개의 필드로 구성된다.

1. 큐로 사용할 배열(que) <br>
인큐하는 데이터를 저장하기 위한 큐 본체용 배열이다. <br>

2. 큐의 최대 용량(max) <br>
큐의 최대 용량을 저장하는 필드로, 이 값은 배열 que에 저장할 수 있는 최대 요소의 개수와 같다. <br>

3. 프런트(front) <br>
인큐하는 데이터 가운데 첫 번째 요소의 인덱스를 저장하는 필드이다. <br>

4. 리어(rear) <br>
인큐한 데이터 가운데 맨 나중에 넣은 요소의 하나 뒤의 인덱스를 저장하는 필드이다. <br>

5. 현재 데이터 수(num) <br>
큐에 쌓아 놓은 데이터 수를 나타내는 필드이다. front와 rear의 값이 같은 경우 큐가 비어 있는지, 가득 찼는지 구별할 수 없는 상황을 피하기 위해 이 변수가 필요하다. 큐가 비어 있을때 num은 0이고, 가득 찼을 때는 num과 max의 값이 같다. <br>

큐가 비어 있는 상태와 큐가 가득 찬 상태를 비교하면서 'front와 rear의 값이 같음'으로 큐의 상태가 비어 있는지, 아닌지 구분할 수 없는 경우에 대해 생각해봐야한다. 그런데 큐가 비어 있는 상태와 큐가 가득 찬 상태 전부 front와 rear의 값이 같다. 이렇게 num과 max가 없다면 front와 rear값만으로는 두 상태를 구분할 수 없다. <br>

생성자 IntQueue <br>
생성자는 큐 본체용 배열을 생성하는 등의 준비 작업을 수행한다. 생성 시 큐는 비어 있기 때문에 num, front, rear값을 모두 0으로 한다. 또 매개변수 capacity로 전달받은 '큐의 용량'을 필드 max에 복사하고, 요솟수가 max인 배열 que의 본체를 생성한다. 

인큐 메서드 enque <br>
큐에 데이터를 인큐하는 메서드이다. 인큐에 성공하면 인큐한 값을 그대로 반환한다. 그러나 큐가 가득 차서 인큐할 수 없으면(num >= max 가 성립하면) 예외 OverflowIntQueueException을 던진다.(throw). 처음부터 차례대로 데이터(35, 56, 24, 68, 95, 73, 19)를 넣은 큐에 82를 인큐한다. que[rear](que[2])에 데이터 82를 인큐하고 rear와 num값을 1만큼 증가하면 인큐 작업이 끝난다. 하지만 생각지 못한 문제가 하나 있다. 만약 인큐하기 전의 rear값이 11이면 enque메서드를 수행한 다음에는 rear값이 12가 되면서max(Initialize 메서드에서 초기화한 값 12)와 같아지는 문제가 발생한다. rear값을 1만큼 증가했을 때 큐의 최대 용량의 값인 max와 같아질 경우 rear를 배열의 처음인 0으로 변경해야한다. <br> 

디큐 메서드 deque <br>
큐에서 데이터를 디큐하고 그 값을 반환하는 메서드이다. 그러나 큐가 비어 있어 디큐할 수없으면(num <= 0이 설입하면) 예외 EmptyIntQueueException을 던진다(throw). 디큐를 수행하는 과정 중의 하나로, 처음부터 차례대로 데이터 8개(35, 56, 24, 68, 95, 73, 19, 82)를 저장한 큐에서 35를 디큐하는 모습이다. que[front](que[7])에 저장한 값 35를 꺼내고 front값을 1만큼 증가한 다음 num값을 1만큼 감소한다. <br>

여기서 인큐와 마찬가지로 디큐도 인덱스 초과 문제가 발생한다. 디큐하기 전의 front값이 배열의 끝(11)이라면 위의 과정을 거치고 난 후의 front값은 max(12)가 되어 배열 마지막 요소의 인덱스를 초과한다. <br>

피크 메서드 peek <br>
맨 앞의 데이터(디큐에서 꺼낼 데이터)를 몰래 엿보는 메서드이다. que[front]의 값을 조사만 하고 데이터를 꺼내지 않으므로 front, rear, num의 값이 변화하지 않는다. 큐가 비어 있으면 예외 EmptyIntQueueException을 던진다(throw). <br>

검색 메서드 indexOf <br>
큐의 배열에서 x와 같은 데이터가 저장되어 있는 위치를 알아내는 메서드이다. 프론트에서 리어 쪽으로 선형 검색을 수행한다. 스캔의 시작은 배열의 첫 요소가 아니라 큐의 첫 요소, 즉 프런트이다. 그래서 스캔할 때 주목하는 인덱스 idx의 계산이 (i + front) % max로 복잡하다. 검색이 성곡하면 찾은 요소의 인덱스를 반환하고 실패하면 -1을 반환한다. <br>

모든 데이터를 삭제하는 메서드 clear <br>
현재 큐의 모든 데이터를 삭제하는 메서드이다. 인큐, 디큐는 num, front, rear 값을 바탕으로 값을 0으로 바꾼다. 실제 큐의 배열 요솟값을 바꿀 필요가 없다. <br>

최대 용량을 확인하는 메서드 capacity <br>
큐의 최대 용량을 반환하는 메서드이다(필드 max의 값을 그래도 반환한다). <br>

데이터 수를 확인하는 메서드 size <br>
현재 큐의 데이터 수를 반환하는 메서드이다(필드 num의 값을 그대로 반환한다). <br>

큐가 비어 있는지 판단하는 메서드 IsEmpty <br>
큐가 비어 있는지 판단하는 메서드이다. 비어있으면 true, 그렇지 않으면 false를 반환한다. <br>

큐가 가득 찼는지 판단하는 메서드 IsFull <br>
큐가 가득 찼는지 판단하는 메서드이다. 가득 찼으면 true, 그렇지 않으면 false를 반환한다. <br>

모든 데이터를 출력하는 메서드 dump <br>
큐에 인큐된 모든(num개) 데이터를 프런트에서 리어 순으로 출력하는 메서드이다. 큐가 비어 있으면 큐가 비어 있다. 라고 표시한다.

- 这个项目是我为了重新学习Algorithm而做的项目（이 프로젝트는 내가 Algorithm를 다시 공부하기위해서 만든 프로젝트입니다.）
